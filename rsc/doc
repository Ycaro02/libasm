GDB PEDA
https://gitlab.com/kalilinux/packages/gdb-peda
Run gdb
    - start
    - ni for each instuction

https://beta.hackndo.com/buffer-overflow/                               --> buffer owerflow with asm example

https://en.wikipedia.org/wiki/X86_instruction_listings                  --> Instruction
https://beta.hackndo.com/stack-introduction/#prologue---%C3%A9pilogue

https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/     --> Syscalls

https://www.eecg.utoronto.ca/~amza/www.mindsec.com/files/x86regs.html   --> Registers info
https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture

https://onecompiler.com/assembly/423f8fy9n                              --> Online assembly compiler


https://stackoverflow.com/questions/26783797/repnz-scas-assembly-instruction-specifics  --> how to while on string
- repnz scasb:
repnz means "repeat until zero flag is not set and cx is not zero". Each iteration decrements ecx. 
scas or more precisely scasb compares the value in al to the memory operand (always es:[edi] or es:[di] depending on address size), 
then sets the flags accordingly (zero flag will be set if the two values equal) and increments (or decrements, based on the direction flag) edi.

https://docs.oracle.com/cd/E19620-01/805-4693/instructionset-64/index.html  --> how to copy data 
movsb move data from string to string 

Use the rep (repeat while equal), repnz (repeat while nonzero) or repz (repeat while zero) prefixes in conjunction with string operations. 
Each prefix causes the associated string instruction to repeat until the count register (CX) or the zero flag (ZF) matches a tested condition.

;push	rbp			; Save the stack frame of caller, pushed on stack 
;mov 	rbp, rsp	; Set my own stack frame
;pop 	rbp			; Pop rbp to restore stack


MOVSXD	Cette instruction permet de copier un registre de taille inférieur dans un registre 64 bits en remplissant les bits supplémentaires avec l'extension des signes.

MOVZX : operandedestination(register), operandesource
- Cette instruction permet de copier un registre de taille inférieur dans un registre de plus grande taille en remplissant les bits supplémentaires par des 0.

TEST : and & logic

https://www.tutorialspoint.com/assembly_programming/assembly_conditions.htm ----> jump usage

https://www.unilim.fr/pages_perso/tristan.vaccon/cours_nasm.pdf ---> nasm cours


/* gcc basic strlen version, basic while with jump and label, and iter on string */

ft_strlen:
	push   rbp                      ; save rbp
	mov    rbp,rsp                  ; set my own rbb with rsb value
	mov    QWORD [rbp-0x18],rdi     ; store rdi/args pointer in stack rbp - 0x18
	mov    QWORD [rbp-0x8],0x0      ; store index in statck rbp - ox8

	cmp		rdi, 0x0		; rdi NULL
	je		_ft_strlen_exit ; jump equal exit
	jmp    _ft_strlen_mov   ; jmp start while

_ft_strlen_add:             
	add    QWORD [rbp-0x8],0x1  ; increment index

;rbp-0x18    = str
;rbp-0x8     = i

_ft_strlen_mov:             ; start while
    ;rdx = str
	mov    rdx,QWORD [rbp-0x18]     ; store args pointer value in rdx
    ;rax = i
	mov    rax,QWORD [rbp-0x8]      ; store index in rax
    ;rax += str AKA str += i AKA str + i
	add    rax,rdx                  ; rax += rdx, we are a the good adress to take char
    ;char c = *rax
    movzx  eax,BYTE [rax]           ; put byte rax in eax
    ;c == 0 
    test   al,al                    ; test al, al is a sub register of eax, represent lowerbyte
    ;if c not equal 0 jump to add
    jne    _ft_strlen_add


_ft_strlen_exit:
	mov    rax,QWORD [rbp-0x8]
	pop    rbp
	ret